# 6章 項の名無し表現（Nameless Representation of Terms）

```toc
```
## はじめに
前章では，項を「束縛変数の名前の違いを除いて」扱った．

（例）
```mathjaxBlock
\begin{align}
\left.
  \begin{array}{ll}
  \mathtt{t}_{1} &=\lambda\mathtt{a}.\ \mathtt{a} \\
  \mathtt{t}_{2} &=\lambda\mathtt{b}.\ \mathtt{b}
  \end{array}
\right\}
\mathtt{t}_{1}と\mathtt{t}_{2}は束縛変数の名前が違うだけなので，
\mathtt{t}_{1}=\mathtt{t}_{2}
\end{align}
```

### 変数の出現に対する表現方法

1. 変数を記号的に表現する
代入の際に束縛変数を明示的に **フレッシュ** な名前に置き換える．
```mathjaxBlock
\begin{align}
                               & \underline{(\lambda\mathtt{x}.\ \mathtt{x}\ \mathbf{y})(\lambda\mathtt{y}.\ \mathtt{y})} & 項として存在できる \\
\longrightarrow\quad           & (\lambda\mathtt{y}.\ \mathtt{y}\ \mathbf{y})                                             & 変数捕獲が起きる   \\
\longrightarrow_{名前変更}\quad& (\lambda\mathtt{z}.\ \mathtt{z}\ \mathbf{y})                                                                  \\
\end{align}
```
2. 変数を記号的に表現する（1よりも厳しい）
    - 不変条件1: 束縛変数の名前はすべて互いに異なる
    `$(\lambda\underline{\mathtt{x}}.\ \mathtt{x})(\lambda\underline{\mathtt{x}}.\ \mathtt{x})$` ... だめ
    - 不変条件2: 使う可能性のあるどの自由変数とも異なる
    `$(\lambda\mathtt{x}.\ \mathtt{x}\ \underline{\mathtt{y}})(\lambda\underline{\mathtt{y}}.\ \mathtt{y})$` ... だめ
この慣習はBarendregtの慣習とも呼ばれ，任意の時点での「その場での」名前の付替えを許容しない．
しかし，安定ではない．なぜなら，代入操作は代入される項の複製を伴うから．
```mathjaxBlock
\begin{align}
                               & \underline{(\lambda\mathtt{x}.\ \mathtt{x}\ \mathtt{x})(\lambda\mathtt{y}.\ \mathtt{y})}                                      \\
\longrightarrow\quad           & (\lambda\underline{\mathtt{y}}.\ \mathtt{y})(\lambda\underline{\mathtt{y}}.\ \mathtt{y}) & 不変条件を回復するための処理が必要 \\
\longrightarrow_{名前変更}\quad&  (\lambda\mathtt{y}'.\ \mathtt{y}')(\lambda\mathtt{y}''.\ \mathtt{y}'')
\end{align}
```
3. 名前を変更する必要のない，変数および項の「標準の」表現を考える（ **名前をなくす** ）
→本書の方針
4. 明示的代入などの仕組みを導入することで，代入操作を避ける（ **代入をなくす** ）
5. 変数の使用を完全に避ける
コンビネータ論理を扱う．コンビネータとは自由変数を含まない項（閉じた項）のこと．
```mathjaxBlock
\begin{align}
                    & \underline{(\lambda\mathtt{x}.\ \mathtt{y}\ \mathtt{x}\ \mathtt{y})(\lambda\mathtt{y}.\ \mathtt{y})}    \\
\longrightarrow\quad& \lambda\mathtt{y}.\ (\lambda\mathbf{y}.\ \mathbf{y})\ \mathtt{y} & スコープが異なるから大丈夫なのかな？ \\
\end{align}
```

- 本書で3の表現方法を選ぶ理由
実装が間違っている場合に，微妙に失敗するのではなく，
**壊滅的に失敗** する傾向があるため．
すなわち，比較的早く間違いを検出し，修正できる．
定式化の方法として，Nicolas de Bruijn による技法を用いる．

## 6.1 項と文脈
アイデア！: 変数の出現を **名前** ではなく， **束縛子を直接指す** ことで項を表現

（例）

|通常の項                                                     |名無し項（内側から番号を振る）                            |
|:------------------------------------------------------------|:---------------------------------------------------------|
|`$\lambda\mathtt{x}.\ \mathtt{x}$`                           |`$\lambda.\ \mathtt{0}$`                                  |
|`$\lambda\mathtt{x}.\ \lambda{y}.\ (\mathtt{y}\ \mathtt{x})$`|`$\lambda.\lambda.\ \mathtt{1}\ (\mathtt{0}\ \mathtt{1})$`|

名無し項は，de Bruijn 項とも呼ばれる．
`$\lambda.\ \mathtt{0}$` の `$\mathtt{0}$` はde Bruijnインデックス（自然数）と呼ばれ，
コンパイラの人は静的距離とも呼ぶ．

### 演習 6.1.1 \[`$\star$`\]
**解答**

|                  |通常の項                                                                                                                                                                                                          |名無し項                                                                                                                                            |
|:-----------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|:---------------------------------------------------------------------------------------------------------------------------------------------------|
|`$\mathtt{c}_{0}$`|`$\lambda\mathtt{s}.\ \lambda\mathtt{z}.\ \mathtt{z}$`                                                                                                                                                            |`$\lambda.\lambda.\mathtt{0}$`                                                                                                                      |
|`$\mathtt{c}_{2}$`|`$\lambda\mathtt{s}.\ \lambda\mathtt{z}.\ \mathtt{s}\ (\mathtt{s}\ \mathtt{z})$`                                                                                                                                  |`$\lambda.\lambda.\mathtt{1}\ (\mathtt{1}\ \mathtt{0})$`                                                                                            |
|`$\mathtt{plus}$` |`$\lambda\mathtt{m}.\ \lambda\mathtt{n}.\ \lambda\mathtt{s}.\ \lambda\mathtt{z}.\ \mathtt{m}\ \mathtt{s}\ (\mathtt{n}\ \mathtt{s}\ \mathtt{z})$`                                                                  |`$\lambda.\lambda.\lambda.\lambda.\mathtt{3}\ \mathtt{1}\ (\mathtt{2}\ \mathtt{1}\ \mathtt{0})$`                                                    |
|`$\mathtt{fix}$`  |`$\lambda\mathtt{f}.\ (\lambda\mathtt{x}.\ \mathtt{f}\ (\lambda\mathtt{y}.\ (\mathtt{x}\ \mathtt{x})\ \mathtt{y}))\ (\lambda\mathtt{x}.\ \mathtt{f}\ (\lambda\mathtt{y}.\ (\mathtt{x}\ \mathtt{x})\ \mathtt{y}))$`|`$\lambda.(\lambda.\mathtt{1}\ (\lambda.(\mathtt{1}\ \mathtt{1})\ \mathtt{0}))(\lambda.\mathtt{1}\ (\lambda.(\mathtt{1}\ \mathtt{1})\ \mathtt{0}))$`|
|`$\mathtt{foo}$`  |`$(\lambda\mathtt{x}.\ (\lambda\mathtt{x}.\ \mathtt{x}))\ (\lambda\mathtt{x}.\ \mathtt{x})$`                                                                                                                      |`$(\lambda.(\lambda.\mathtt{0}))(\lambda.\mathtt{0})$`                                                                                              |

### 定義 6.1.2
`$\mathcal{T}$` を以下の条件を満たす集合の最小の族 `$\{\mathcal{T}_{0}, \mathcal{T}_{1}, \mathcal{T}_{2}, \ldots\}$` とする．
1. `$0 \leq \mathtt{k} < n$` ならば `$\mathtt{k} \in \mathcal{T}_{n}$`
    - `$\mathtt{k}$` は自由変数（識別子）
2. `$\mathtt{t}_{1} \in \mathcal{T}_{n}$` かつ `$n > 0$` ならば `$\lambda.\mathtt{t}_{1} \in \mathcal{T}_{n-1}$`
    - （前件）自由変数を最大で `$n$` 個含む項 `$\mathtt{t}_{1}$`に
    - （後件）`$\lambda$` を付けると自由変数を一つ束縛するので，`$\lambda.\mathtt{t}_{1}$` は `$\mathcal{T}_{n-1}$`に属する
3. `$\mathtt{t}_{1} \in \mathcal{T}_{n}$` かつ `$\mathtt{t}_{2} \in \mathcal{T}_{n}$` ならば `$(\mathtt{t}_{1}\ \mathtt{t}_{2}) \in \mathcal{T}_{n}$`

（例）
```mathjaxBlock
\begin{align}
\mathcal{T}_{0}=& \quad \{\lambda.\mathtt{0},\ \lambda.\lambda.\mathtt{1},\ \ldots\}                                     & 自由変数0の集合 \\
\mathcal{T}_{1}=& \quad \{\lambda.\mathtt{x},\ \lambda.\lambda.\mathtt{y},\ \lambda.\mathtt{0}\ \mathtt{z}\ldots\}       & 自由変数1の集合 \\
\mathcal{T}_{2}=& \quad \{\lambda.\mathtt{x}\ \mathtt{y},\ \lambda.\mathtt{0},\ \lambda.\mathtt{z}\ \mathtt{y},\ \ldots\}& 自由変数2の集合 \\
                & \vdots                                                                                                 &                 \\
\mathcal{T}_{n}=& \quad \{\ldots\}                                                                                       & 自由変数nの集合 \\
\end{align}
```

注意点
- 一つの集合を定義しているのではない
- 数で添字付けられた **集合族** を定義している

`$\mathcal{T}_{n}$` を `$n$` 項と呼ぶ
- 高々 `$n$` 種類の自由変数を持つ
- `$0$` から `$n-1$` の数が振られる
- `$\mathcal{T}_{n}$` の要素に **`$0$` から `$n-1$` までのすべての数が振られた自由変数が含まれる必要はない**
（例）
```mathjaxBlock
\begin{align}
\mathcal{T}_{2}=& \quad \{\lambda.\mathtt{x},\ \lambda.\lambda.\mathtt{x}\ \mathtt{y},\ \ldots,\ \lambda.\mathtt{0}\ \mathtt{x},\ \lambda.\mathtt{0},\ \ldots\}
\end{align}
```

- 閉じた項 `$\mathtt{t}$` は任意の `$n$` について `$\mathcal{T}_{n}$` に属する
- 閉じた通常の項はそれぞれ唯一の de Bruijn 表現を持つ
```mathjaxBlock
\begin{align}
\lambda\mathtt{x}.\ \mathtt{x} \longrightarrow \lambda.\mathtt{0}
\end{align}
```
- 2つの通常の項を考えたとき，束縛変数名の違いを無視して等しい（⇔ de Bruijn 表現も等しい）
```mathjaxBlock
\begin{align}
\lambda\mathtt{x}.\ \mathtt{x} \longrightarrow \lambda.\mathtt{0} \\
\lambda\mathtt{y}.\ \mathtt{y} \longrightarrow \lambda.\mathtt{0}
\end{align}
```

|                                              |自由変数                                         |束縛変数                 |
|:---------------------------------------------|:------------------------------------------------|:------------------------|
|`$\lambda\mathtt{x}.\ \mathtt{x}$`            |--                                               |`$\mathtt{x}=\mathtt{0}$`|
|`$\lambda\mathtt{x}.\ \mathtt{x}\ \mathtt{y}$`|`$\mathtt{y}=\mathtt{0}$`                        |`$\mathtt{x}=\mathtt{0}$`|
|`$\lambda\mathtt{x}.\ \mathtt{y}\ \mathtt{z}$`|`$\mathtt{y}=\mathtt{0},\ \mathtt{z}=\mathtt{1}$`|`$\mathtt{x}=\mathtt{0}$`|


**名前付け文脈** は **自由変数を含む項を扱う** ために必要

（例）`$\mathtt{y}$` が何番であるか分からない
```mathjaxBlock
\begin{align}
\lambda\mathtt{x}.\ \mathtt{y}\ \mathtt{x} \longrightarrow \lambda.\ \mathtt{y}\ \mathtt{0}
\end{align}
```

**解決策**
自由変数の de Bruijn インデックスの割り当て方（名前付け文脈）決めておく

（例）

```mathjaxBlock
\begin{align}
\Gamma &&= && \mathtt{x} \mapsto 4 \\
       &&  && \mathtt{y} \mapsto 3 \\
       &&  && \mathtt{z} \mapsto 2 \\
       &&  && \mathtt{a} \mapsto 1 \\
       &&  && \mathtt{b} \mapsto 0
\end{align}
```

```mathjaxBlock
\begin{align}
\mathtt{x}\ \mathtt{(y}\ \mathtt{z)} \longrightarrow              & \quad\mathtt{4}\ \mathtt{(3}\ \mathtt{2)} \\
                                                                                                              \\
\lambda\mathtt{w}.\ \mathtt{y}\ \mathtt{w} \longrightarrow        & \quad\lambda.\mathtt{y}\ \mathtt{0}       \\
                                           \longrightarrow        & \quad\lambda.(\mathtt{3+1})\ \mathtt{0}   \\
                                           \longrightarrow        & \quad\lambda.\mathtt{4}\ \mathtt{0}       \\
                                                                                                              \\
\lambda\mathtt{w}.\ \lambda\mathtt{x}.\ \mathtt{x} \longrightarrow& \quad\lambda.\lambda.(\mathtt{4+2})       \\
                                                   \longrightarrow& \quad\lambda.\lambda.\mathtt{6}
\end{align}
```

変数のインデックスは `$\Gamma$` に出現する順序で決まるので，列として書くことができる．

```mathjaxBlock
\begin{align}
\begin{array}{ll}
\Gamma &= &\mathtt{x} \mapsto 4 \\
       &  &\mathtt{y} \mapsto 3 \\
       &  &\mathtt{z} \mapsto 2 \\
       &  &\mathtt{a} \mapsto 1 \\
       &  &\mathtt{b} \mapsto 0
\end{array}
\quad
\xrightarrow{列の表現}
\quad
\begin{array}{llllll}
\Gamma &= &\mathtt{x}, &\mathtt{y}, &\mathtt{z}, &\mathtt{a}, &\mathtt{b} \\
       &  &4           &3           &2           &1           &0
\end{array}
\end{align}
```

### 定義 6.1.3
- `$\mathtt{x}_{0}$` から `$\mathtt{x}_{n}$` を `$\mathcal{V}$` から取ってきた変数名とする
- 名前付け文脈 `$\Gamma = \mathtt{x}_{n},\mathtt{x}_{n-1},\ldots,\mathtt{x}_{1},\mathtt{x}_{0}$` とは，各 `$\mathtt{x}_{i}$` に de Bruijn インデックス `$i$` を割り振ったものである
- 列の中で **右端にある変数に `$0$`** を与える

```mathjaxBlock
\begin{align}
dom(\Gamma) = \{\mathtt{x}_{n},\mathtt{x}_{n-1},\ldots,\mathtt{x}_{1},\mathtt{x}_{0}\}
\end{align}
```

### 演習 6.1.4 \[`$\star\star\star\nrightarrow$`\]
### 演習 6.1.5 \[Recommended, `$\star\star\star$`\]
1. 通常の項から名無し項に変換する関数 `$removenames_{\Gamma}(\mathtt{t})$`
    ```mathjaxBlock
\begin{align}
removenames_{\Gamma}(\mathtt{t}) :: \Gamma \to 通常の項 \to 名無し項
\end{align}
    ```
    - 例1
        - `$\mathtt{t} = \lambda\mathtt{s}.\ \lambda\mathtt{z}.\ \mathtt{z}$`
        - `$dom(\Gamma) = \varnothing$`
        ```mathjaxBlock
\begin{align}
removenames_{\Gamma}(\mathtt{t}) = \lambda.\lambda.\mathtt{0}
\end{align}
        ```
    - 例2
        - `$\mathtt{t} = \lambda\mathtt{w}.\ \lambda\mathtt{a}.\ \mathtt{x}$`
        - `$dom(\Gamma) = \{ \mathtt{x},\mathtt{y},\mathtt{z},\mathtt{a},\mathtt{b} \}$`
            - `$FV(\mathtt{t}) = \{\mathtt{x}\}$`
        ```mathjaxBlock
\begin{align}
removenames_{\Gamma}(\mathtt{t}) = \lambda.\lambda.\mathtt{6}
\end{align}
        ```
2. 名無し項から通常の項に変換する関数 `$restorenames_{\Gamma}(\mathtt{t})$`
    ```mathjaxBlock
\begin{align}
restorenames_{\Gamma}(\mathtt{t}) :: 名無し項 \to \Gamma \to 通常の項
\end{align}
    ```
    - 仮定
        - `$\Gamma$` に含まれる名前は互いに異なる（→束縛変数は含まない）
        - 変数名の集合 `$\mathcal{V}$` は順序付けられている
- **満たすべき性質**
    - 任意の名無し項 `$\mathtt{t}$` について `$removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t})) = \mathtt{t}$`
    - 任意の通常の項 `$\mathtt{t}$` について `$restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t})) = \mathtt{t}$`
        - ただし，束縛変数名の付け替えによる違いは無視する


**解答**
- `$removenames_{\Gamma}(\mathtt{t})$` の定義
    ```mathjaxBlock
\begin{align}
&removenames_{\Gamma}(\mathtt{x})                     &=&& & \Gamma(\mathtt{x})                                                         \\
&removenames_{\Gamma}(\lambda\mathtt{x}.\mathtt{t})   &=&& & \lambda.removenames_{\Gamma,\mathtt{x}}(\mathtt{t})                        \\
&removenames_{\Gamma}(\mathtt{t}_{1}\ \mathtt{t}_{2}) &=&& & removenames_{\Gamma}(\mathtt{t}_{1})\ removenames_{\Gamma}(\mathtt{t}_{2}) \\
\end{align}
    ```
    - ただし，文脈 `$\Gamma$` の最後に自由変数 `$\mathtt{x}$` を追加することを `$\Gamma,\mathtt{x}$` と表現する．
- `$restorenames_{\Gamma}(\mathtt{t})$` の定義
    ```mathjaxBlock
\begin{align}
&restorenames_{\Gamma}(\mathtt{k})                     &=&& & \Gamma の \mathtt{k} 番目の変数名                                            \\
&restorenames_{\Gamma}(\lambda.\mathtt{t})             &=&& & \lambda\mathtt{x}.restorenames_{\Gamma,\mathtt{x}}(\mathtt{t})               \\
&                                                      & && & ただし， \mathtt{x} \notin dom(\Gamma)                                       \\
&restorenames_{\Gamma}(\mathtt{t}_{1}\ \mathtt{t}_{2}) &=&& & restorenames_{\Gamma}(\mathtt{t}_{1})\ restorenames_{\Gamma}(\mathtt{t}_{2})
\end{align}
    ```
    - ただし，文脈 `$\Gamma$` の最後に自由変数 `$\mathtt{x}$` を追加することを `$\Gamma,\mathtt{x}$` と表現する．
- 任意の名無し項 `$\mathtt{t}$` について `$removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t})) = \mathtt{t}$` を証明
    - `$\mathtt{t}=\mathtt{k}$` の場合（ただし， `$\mathtt{k} \in cod({\Gamma})$` を仮定）
    ```mathjaxBlock
\begin{align}
&               && removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{k})) = \mathtt{k} \\
&\Leftrightarrow&& removenames_{\Gamma}(\Gamma の \mathtt{k} 番目の変数名) = \mathtt{k} \\
&\Leftrightarrow&& \Gamma(\Gamma の \mathtt{k} 番目の変数名) = \mathtt{k}               \\
&\Leftrightarrow&& \mathtt{k} = \mathtt{k}
\end{align}
    ```
    - `$\mathtt{t}=\lambda.\mathtt{t}_{1}$` の場合
      （帰納法の仮定: `$\mathtt{t}$` の部分項 `$\mathtt{t}_{1}$` について，
      `$removenames_{\Gamma,\mathtt{a}}(restorenames_{\Gamma,\mathtt{a}}(\mathtt{t}_{1}))=\mathtt{t}_{1}$` が成り立つ．）
    ```mathjaxBlock
\begin{align}
&               && removenames_{\Gamma}(restorenames_{\Gamma}(\lambda.\mathtt{t}_{1})) = \lambda.\mathtt{t}_{1}                        \\
&\Leftrightarrow&& removenames_{\Gamma}(\lambda\mathtt{x}.\ restorenames_{\Gamma,\mathtt{x}}(\mathtt{t}_{1})) = \lambda.\mathtt{t}_{1} \\
&               && ただし， \mathtt{x} \notin dom(\Gamma)                                                                              \\
&\Leftrightarrow&& \lambda.removenames_{\Gamma,\mathtt{x}}(restorenames_{\Gamma,\mathtt{x}}(\mathtt{t}_{1})) = \lambda.\mathtt{t}_{1}  \\
&\Leftrightarrow&& 帰納法の仮定より                                                                                                    \\
&               && \lambda.\mathtt{t}_{1} = \lambda.\mathtt{t}_{1}
\end{align}
    ```
    - `$\mathtt{t}=\mathtt{t}_{1}\ \mathtt{t}_{2}$` の場合
      （帰納法の仮定: `$\mathtt{t}$` の部分項 `$\mathtt{t}_{1}, \mathtt{t}_{2}$` について，
      `$removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{1}))=\mathtt{t}_{1}$` と
      `$removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{2}))=\mathtt{t}_{2}$` が成り立つ．）
    ```mathjaxBlock
\begin{align}
&               && removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{1}\ \mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2}                                              \\
&\Leftrightarrow&& removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{1})\ restorenames_{\Gamma}(\mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2}                       \\
&\Leftrightarrow&& removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{1}))\ removenames_{\Gamma}(restorenames_{\Gamma}(\mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2} \\
&\Leftrightarrow&& 帰納法の仮定より                                                                                                                                          \\
&               && \mathtt{t}_{1}\ \mathtt{t}_{2} = \mathtt{t}_{1}\ \mathtt{t}_{2}
\end{align}
    ```
- 任意の通常の項 `$\mathtt{t}$` について `$restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t})) = \mathtt{t}$` を証明
    - `$\mathtt{t}=\mathtt{x}$` の場合
    ```mathjaxBlock
\begin{align}
&               && restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{x})) = \mathtt{x} \\
&\Leftrightarrow&& restorenames_{\Gamma}(\Gamma(\mathtt{x})) = \mathtt{x}               \\
&\Leftrightarrow&& \Gamma の \Gamma(\mathtt{x}) 番目の変数名 = \mathtt{x}               \\
&\Leftrightarrow&& \mathtt{x} = \mathtt{x}
\end{align}
    ```
    - `$\mathtt{t}=\lambda\mathtt{x}.\mathtt{t}_{1}$` の場合
      （帰納法の仮定: `$\mathtt{t}$` の部分項 `$\mathtt{t}_{1}$` について，
      `$restorenames_{\Gamma,\mathtt{a}}(removenames_{\Gamma,\mathtt{a}}(\mathtt{t}_{1}))=\mathtt{t}_{1}$` が成り立つ．）
    ```mathjaxBlock
\begin{align}
&               && restorenames_{\Gamma}(removenames_{\Gamma}(\lambda\mathtt{x}.\ \mathtt{t}_{1})) = \lambda\mathtt{x}.\ \mathtt{t}_{1}                       \\
&\Leftrightarrow&& restorenames_{\Gamma}(\lambda.removenames_{\Gamma,\mathtt{x}}(\mathtt{t}_{1})) = \lambda\mathtt{x}.\ \mathtt{t}_{1}                        \\
&\Leftrightarrow&& \lambda\mathtt{x}.\ restorenames_{\Gamma,\mathtt{x}}(removenames_{\Gamma,\mathtt{x}}(\mathtt{t}_{1})) = \lambda\mathtt{x}.\ \mathtt{t}_{1} \\
&               && ただし， \mathtt{x} \notin dom(\Gamma)                                                                                                     \\
&\Leftrightarrow&& 帰納法の仮定より                                                                                                                           \\
&               && \lambda\mathtt{x}.\ \mathtt{t}_{1} = \lambda\mathtt{x}.\ \mathtt{t}_{1}
\end{align}
    ```
    - `$\mathtt{t}=\mathtt{t}_{1}\ \mathtt{t}_{2}$` の場合
      （帰納法の仮定: `$\mathtt{t}$` の部分項 `$\mathtt{t}_{1}, \mathtt{t}_{2}$` について，
      `$restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{1}))=\mathtt{t}_{1}$` と
      `$restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{2}))=\mathtt{t}_{2}$` が成り立つ．）
    ```mathjaxBlock
\begin{align}
&               && restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{1}\ \mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2}                                              \\
&\Leftrightarrow&& restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{1})\ removenames_{\Gamma}(\mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2}                        \\
&\Leftrightarrow&& restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{1}))\ restorenames_{\Gamma}(removenames_{\Gamma}(\mathtt{t}_{2})) = \mathtt{t}_{1}\ \mathtt{t}_{2} \\
&\Leftrightarrow&& 帰納法の仮定より                                                                                                                                          \\
&               && \mathtt{t}_{1}\ \mathtt{t}_{2} = \mathtt{t}_{1}\ \mathtt{t}_{2}
\end{align}
    ```


## 6.2 シフトと代入
- 名無し項に対する代入操作の定義
```mathjaxBlock
\begin{align}
[\mathtt{k}\mapsto\mathtt{s}]\mathtt{t}
\end{align}
```
- 実現のためには **シフト** と呼ばれる操作が必要
- **シフト** とは，自由変数のインデックスを付け替えること

（例）
- 名無し項 `$[\mathtt{1}\mapsto\mathtt{s}](\lambda.\mathtt{2})$`
- 通常の項 `$[\mathtt{x}\mapsto\mathtt{s}](\lambda\mathtt{y}.\ \mathtt{x})$`
```mathjaxBlock
\begin{align}
                            & [\mathtt{x}\mapsto\mathtt{s}](\lambda\mathtt{y}.\ \mathtt{x}) \\
\longrightarrow_{代入}\quad & (\lambda\mathtt{y}.\ \mathtt{s})
\end{align}
```
つまり，代入より `$\lambda$` が1つ外側に付くので，
`$\mathtt{s}$` の自由変数は `$+1$` する必要がある．

注意点
- `$\mathtt{s}$` の中の全ての変数についてインデックスを1シフトできない
- 理由は束縛変数もシフトしてしまうから

（例）
- 項と文脈
    - 通常の項 `$\mathtt{s} = \mathtt{z}(\lambda\mathtt{w}.\ \mathtt{w})$`
    - 名無し項 `$\mathtt{s} = \mathtt{2}(\lambda.\mathtt{0})$`
    - 変数名の集合 `$dom(\Gamma) = \{\mathtt{z}\}$`
- まちがい
```mathjaxBlock
\begin{align}
\mathtt{s} &= \mathtt{2}(\lambda.\mathtt{0})         \\
           &= (\mathtt{2}+1)(\lambda.(\mathtt{0}+1)) \\
           &= \mathtt{3}(\lambda.\mathtt{1})
\end{align}
```
- 正しい
```mathjaxBlock
\begin{align}
\mathtt{s} &= \mathtt{2}(\lambda.\mathtt{0})     \\
           &= (\mathtt{2}+1)(\lambda.\mathtt{0}) \\
           &= \mathtt{3}(\lambda.\mathtt{0})
\end{align}
```

シフト関数
- 打ち切り値パラメータ `$c$`
    - どの変数をシフトするか
    - `$0$` から始まる
- シフト関数が束縛子を通るたびに `$c$` に `$1$` が加えられる
    - `$k < c$` の場合はシフト NG
    - `$k \geq c$` の場合はシフト OK

### 定義 6.2.1 シフト
- 項 `$\mathtt{t}$`
- 打ち切り値 `$c$`
- シフト数 `$d$`

```mathjaxBlock
\begin{align}
&\uparrow_{c}^{d}(\mathtt{k})                    & =&& &
\left\{
  \begin{array}{ll}
  \mathtt{k}  & \mathtt{k} < c    \ の場合（\mathtt{k}\;は束縛変数） \\
  \mathtt{k}+d& \mathtt{k} \geq c \ の場合
  \end{array}
\right.                                                                                                                    \\
&\uparrow_{c}^{d}(\lambda.\mathtt{t}_{1})        & =&& & \lambda.\uparrow_{c+1}^{d}(\mathtt{t}_{1})                        \\
&\uparrow_{c}^{d}(\mathtt{t}_{1}\ \mathtt{t}_{2})& =&& & \uparrow_{c}^{d}(\mathtt{t}_{1}) \uparrow_{c}^{d}(\mathtt{t}_{2})
\end{align}
```

`$\uparrow^{d}(\mathtt{t})$` は `$\uparrow_{0}^{d}(\mathtt{t})$` を表すとする．

（例）
```mathjaxBlock
\begin{align}
\uparrow_{0}^{d}(\lambda.\lambda.\mathtt{6})& = \lambda.\uparrow_{1}^{d}(\lambda.\mathtt{6})        \\
                                            & = \lambda.\lambda.\uparrow_{2}^{d}(\mathtt{6})        \\
                                            & ここで\;\mathtt{k}=6,c=2\;なので\;k \geq c\;より\;d\;シフトされる \\
                                            & = \lambda.\lambda.(\mathtt{6}+d)
\end{align}
```

### 演習 6.2.2 \[`$\star$`\]
**解答**
1. `$\uparrow^{2}(\lambda.\lambda.\mathtt{1}\ (\mathtt{0}\ \mathtt{2}))$`
```mathjaxBlock
\begin{align}
\uparrow_{0}^{2}(\lambda.\lambda.\mathtt{1}\ (\mathtt{0}\ \mathtt{2}))& = \lambda.\uparrow_{1}^{2}(\lambda.(\mathtt{1}\ (\mathtt{0}\ \mathtt{2})))               \\
                                                                      & = \lambda.\lambda.\uparrow_{2}^{2}(\mathtt{1}\ (\mathtt{0}\ \mathtt{2}))                 \\
                                                                      & = \lambda.\lambda.\uparrow_{2}^{2}(\mathtt{1})\ \uparrow_{2}^{2}(\mathtt{0}\ \mathtt{2}) \\
                                                                      & = \lambda.\lambda.\mathtt{1}\ \uparrow_{2}^{2}(\mathtt{0})\ \uparrow_{2}^{2}(\mathtt{2}) \\
                                                                      & = \lambda.\lambda.\mathtt{1}\ (\mathtt{0}\ \mathtt{4})
\end{align}
```
2. `$\uparrow^{2}(\lambda.\mathtt{0}\ \mathtt{1}\ (\lambda.\mathtt{0}\ \mathtt{1}\ \mathtt{2}))$`
```mathjaxBlock
\begin{align}
\uparrow_{0}^{2}(\lambda.\mathtt{0}\ \mathtt{1}\ (\lambda.\mathtt{0}\ \mathtt{1}\ \mathtt{2}))& = \lambda.\uparrow_{1}^{2}(\mathtt{0}\ \mathtt{1}\ (\lambda.\mathtt{0}\ \mathtt{1}\ \mathtt{2}))                                     \\
                                                                                              & = \lambda.\uparrow_{1}^{2}(\mathtt{0}\ \mathtt{1})\ \uparrow_{1}^{2}(\lambda.\mathtt{0}\ \mathtt{1}\ \mathtt{2})                     \\
                                                                                              & = \lambda.\uparrow_{1}^{2}(\mathtt{0})\ \uparrow_{1}^{2}(\mathtt{1})\ (\lambda.\uparrow_{2}^{2}(\mathtt{0}\ \mathtt{1}\ \mathtt{2})) \\
                                                                                              & = \lambda.\mathtt{0}\ \mathtt{3}\ (\lambda.\uparrow_{2}^{2}(\mathtt{0}\ \mathtt{1})\ \uparrow_{2}^{2}(\mathtt{2}))                   \\
                                                                                              & = \lambda.\mathtt{0}\ \mathtt{3}\ (\lambda.\uparrow_{2}^{2}(\mathtt{0})\ \uparrow_{2}^{2}(\mathtt{1})\ \uparrow_{2}^{2}(\mathtt{2})) \\
                                                                                              & = \lambda.\mathtt{0}\ \mathtt{3}\ (\lambda.\mathtt{0}\ \mathtt{1}\ \mathtt{4})
\end{align}
```

### 演習 6.2.3 \[`$\star\star\nrightarrow$`\]
- `$\mathtt{t}$` は `$n$` 項
- `$d < 0$` の場合， `$\mathtt{t}$` の自由変数はどれも `$|d|$` 以上
このとき， `$\uparrow_{c}^{d}\mathtt{t}$` が `$max(n+d, 0)$` 項であることを示せ

**解答**
- `$n$` 項とは， `$\mathcal{T}_{n}$` の要素のこと
- `$\mathcal{T}_{n}$` とは，自由変数を `$n$` 種類含む集合
- 自由変数は `$0$` から `$(n-1)$` の数として現れる

`$(n-1)$` の自由変数に対して `$d$` シフトした場合， `$n - 1 + d$` となる．
よって， `$n - 1 + d$` 種類の自由変数を持つようになる．
つまり，これは `$n + d$` 項である．

シフトによって自由変数を含まなくなる場合，そのときは `$0$` 項となる．

よって，`$max(n+d, 0)$` 項である．

### 定義 6.2.4 代入
- 項 `$\mathtt{t}$` における変数番号 `$\mathtt{j}$` への項 `$\mathtt{s}$` の代入を `$[\mathtt{j}\mapsto\mathtt{s}]\mathtt{t}$`と書く．
- 値呼び出しを想定しているので，文脈中最後にある変数（`$j=0$`）について興味がある

```mathjaxBlock
\begin{align}
&[\mathtt{j} \mapsto \mathtt{s}]\mathtt{k}                      & =&& &
\left\{
  \begin{array}{ll}
  \mathtt{s}& \mathtt{k} = \mathtt{c} \\
  \mathtt{k}& それ以外
  \end{array}
\right.                                                                                                                                                                \\
&[\mathtt{j} \mapsto \mathtt{s}](\lambda.\mathtt{t}_{1})        & =&& & \lambda.[\mathtt{j}+1 \mapsto \;\uparrow^{1}(\mathtt{s})]\mathtt{t}_{1}                        \\
&[\mathtt{j} \mapsto \mathtt{s}](\mathtt{t}_{1}\ \mathtt{t}_{2})& =&& & ([\mathtt{j} \mapsto \mathtt{s}]\mathtt{t}_{1})([\mathtt{j} \mapsto \mathtt{s}]\mathtt{t}_{2})
\end{align}
```

（例）
```mathjaxBlock
\begin{align}
      & [\mathtt{2} \mapsto \mathtt{10}](\lambda.\lambda.\mathtt{2})                     \\
=\quad& \lambda.[\mathtt{2}+1 \mapsto \;\uparrow_{0}^{1}\mathtt{10}](\lambda.\mathtt{2}) \\
=\quad& \lambda.[\mathtt{3} \mapsto \mathtt{11}](\lambda.\mathtt{2})                     \\
=\quad& \lambda.\lambda.[\mathtt{3}+1 \mapsto \;\uparrow_{0}^{1}\mathtt{11}]\mathtt{2}   \\
=\quad& \lambda.\lambda.[\mathtt{4} \mapsto \mathtt{12}]\mathtt{2}                       \\
=\quad& \lambda.\lambda.\mathtt{2}
\end{align}
```

### 演習 6.2.5 \[`$\star$`\]
### 演習 6.2.6 \[`$\star\star\nrightarrow$`\]
### 演習 6.2.7 \[`$\star\nrightarrow$`\]
スキップ

### 演習 6.2.8 \[Recommended, `$\star\star\star$`\]
