<!DOCTYPE HTML><html><head><meta charset="utf-8"><meta content="width=device-width, initial-scale=1" name="viewport"><title>TAPL</title><link href="https://cdnjs.cloudflare.com/ajax/libs/bulma/0.7.1/css/bulma.min.css" rel="stylesheet"><link href="./css/hilight.css" rel="stylesheet"><link href="./css/base.css" rel="stylesheet"><script defer src="https://use.fontawesome.com/releases/v5.1.0/js/all.js"></script><script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML"></script></head><body><section class="section"><div class="container"><div class="content"><h1 id="3章-型無し算術式">3章 型無し算術式</h1>
<ul>
<li>
<a href="#32-%e6%a7%8b%e6%96%87">3.2 構文</a>
<ul>
<li>
<a href="#%e5%ae%9a%e7%be%a9-321-%e5%b8%b0%e7%b4%8d%e7%9a%84%e3%81%aa%e9%a0%85%e3%81%ae%e5%ae%9a%e7%be%a9">定義 3.2.1 帰納的な項の定義</a>
</li>
<li>
<a href="#%e5%ae%9a%e7%be%a9-323-%e5%85%b7%e4%bd%93%e7%9a%84%e3%81%aa%e9%a0%85%e3%81%ae%e5%ae%9a%e7%be%a9">定義 3.2.3 具体的な項の定義</a>
</li>
</ul>
</li>
<li>
<a href="#33-%e9%a0%85%e3%81%ab%e9%96%a2%e3%81%99%e3%82%8b%e5%b8%b0%e7%b4%8d%e6%b3%95">3.3 項に関する帰納法</a>
<ul>
<li>
<a href="#%e5%ae%9a%e7%be%a9331-consts">定義3.3.1 <span class="math inline">\(Consts\)</span></a>
</li>
<li>
<a href="#%e5%ae%9a%e7%be%a9-332-size">定義 3.3.2 <span class="math inline">\(size\)</span></a>
</li>
<li>
<a href="#%e5%ae%9a%e7%be%a9-332-depth">定義 3.3.2 <span class="math inline">\(depth\)</span></a>
</li>
<li>
<a href="#%e8%a3%9c%e9%a1%8c-333">補題 3.3.3</a>
</li>
<li>
<a href="#%e5%ae%9a%e7%90%86-334-%e6%b7%b1%e3%81%95%e3%81%ab%e9%96%a2%e3%81%99%e3%82%8b%e5%b8%b0%e7%b4%8d%e6%b3%95">定理 3.3.4 深さに関する帰納法</a>
</li>
<li>
<a href="#%e5%ae%9a%e7%90%86-334-%e3%82%b5%e3%82%a4%e3%82%ba%e3%81%ab%e9%96%a2%e3%81%99%e3%82%8b%e5%b8%b0%e7%b4%8d%e6%b3%95">定理 3.3.4 サイズに関する帰納法</a>
</li>
<li>
<a href="#%e5%ae%9a%e7%90%86-334-%e6%a7%8b%e9%80%a0%e7%9a%84%e5%b8%b0%e7%b4%8d%e6%b3%95">定理 3.3.4 構造的帰納法</a>
</li>
</ul>
</li>
<li>
<a href="#34-%e6%84%8f%e5%91%b3%e8%ab%96%e3%81%ae%e3%82%b9%e3%82%bf%e3%82%a4%e3%83%ab">3.4 意味論のスタイル</a>
<ul>
<li>
<a href="#%e6%93%8d%e4%bd%9c%e7%9a%84%e6%84%8f%e5%91%b3%e8%ab%96">操作的意味論</a>
</li>
<li>
<a href="#%e8%a1%a8%e7%a4%ba%e7%9a%84%e6%84%8f%e5%91%b3%e8%ab%96">表示的意味論</a>
</li>
<li>
<a href="#%e5%85%ac%e7%90%86%e7%9a%84%e6%84%8f%e5%91%b3%e8%ab%96">公理的意味論</a>
</li>
</ul>
</li>
<li>
<a href="#35-%e8%a9%95%e4%be%a1-%e7%b0%a1%e7%b4%84">3.5 評価 (簡約)</a>
<ul>
<li>
<a href="#%e9%a0%85%e3%81%ae%e6%a7%8b%e6%96%87">項の構文</a>
</li>
<li>
<a href="#%e9%a0%85%e3%81%ae%e5%80%a4">項の値</a>
</li>
<li>
<a href="#%e9%a0%85%e3%81%ae%e8%a9%95%e4%be%a1%e9%96%a2%e4%bf%82">項の評価関係</a>
<ul>
<li>
<a href="#%e8%a8%88%e7%ae%97%e8%a6%8f%e5%89%87">計算規則</a>
</li>
<li>
<a href="#%e5%90%88%e5%90%8c%e8%a6%8f%e5%89%87">合同規則</a>
</li>
<li>
<a href="#%e3%83%9d%e3%82%a4%e3%83%b3%e3%83%88">ポイント</a>
</li>
</ul>
</li>
<li>
<a href="#%e5%ae%9a%e7%be%a9-351-%e6%8e%a8%e8%ab%96%e8%a6%8f%e5%89%87%e3%81%ae%e3%82%a4%e3%83%b3%e3%82%b9%e3%82%bf%e3%83%b3%e3%82%b9">定義 3.5.1 推論規則のインスタンス</a>
</li>
<li>
<a href="#%e5%ae%9a%e7%be%a9-352">定義 3.5.2</a>
</li>
</ul>
</li>
<li>
<a href="#%e6%97%a5%e6%9c%ac%e8%aa%9e%e3%81%ae%e6%96%87%e7%8c%ae">日本語の文献</a>
</li>
<li>
<a href="#%e8%8b%b1%e8%aa%9e%e3%81%ae%e6%96%87%e7%8c%ae">英語の文献</a>
</li>
<li>
<a href="#%e3%83%8b%e3%83%a5%e3%83%bc%e3%83%9e%e3%83%b3%e3%81%ae%e8%a3%9c%e9%a1%8c">ニューマンの補題</a>
</li>
<li>
<a href="#%e6%95%b4%e7%a4%8e%e5%b8%b0%e7%b4%8d%e6%b3%95">整礎帰納法</a>
</li>
<li>
<a href="#haskell">Haskell</a>
</li>
<li>
<a href="#%e3%82%af%e3%83%8c%e3%83%bc%e3%82%b9%e3%83%99%e3%83%b3%e3%83%87%e3%82%a3%e3%83%83%e3%82%af%e3%82%b9%e5%ae%8c%e5%82%99%e5%8c%96%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0">クヌース・ベンディックス完備化アルゴリズム</a>
</li>
<li>
<a href="#ocaml">Ocaml</a>
</li>
</ul>
<h2 id="32-構文">3.2 構文</h2>
<h3 id="定義-321-帰納的な項の定義">定義 3.2.1 帰納的な項の定義</h3>
<p>Haskell で定義すると、だいたいこんな感じだと思う。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Term</span><span>
  </span><span class="sy">=</span><span> </span><span class="cr">True</span><span>      </span><span class="sy">|</span><span> </span><span class="cr">False</span><span>     </span><span class="sy">|</span><span> </span><span class="cr">Zero</span><span>        </span><span class="co">-- ^ (1)</span><span>
  </span><span class="sy">|</span><span> </span><span class="cr">Succ</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">|</span><span> </span><span class="cr">Pred</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">|</span><span> </span><span class="cr">IsZero</span><span> </span><span class="cr">Term</span><span> </span><span class="co">-- ^ (2)</span><span>
  </span><span class="sy">|</span><span> </span><span class="cr">If</span><span> </span><span class="cr">Term</span><span> </span><span class="cr">Term</span><span> </span><span class="cr">Term</span><span>                   </span><span class="co">-- ^ (3)</span><span>
</span></code></pre></div>
<p><span class="math inline">\(\tau\)</span> は上記からなる最小の集合なので、以下のように定義できる。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">type</span><span> </span><span class="cr">T</span><span> </span><span class="sy">=</span><span> </span><span class="cr">Set</span><span> </span><span class="cr">Term</span><span>
</span></code></pre></div>
<p>GADT を使って書くバージョン (あまり意味はない)</p>
<div class="source-code"><pre><code class="language-haskell"><span class="kw">data</span><span> </span><span class="cr">Term</span><span> </span><span class="kw">where</span><span>
  </span><span class="cr">True</span><span>   </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span>
  </span><span class="cr">False</span><span>  </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span>
  </span><span class="cr">Succ</span><span>   </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Term</span><span>
  </span><span class="cr">Pred</span><span>   </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Term</span><span>
  </span><span class="cr">IsZero</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Term</span><span>
  </span><span class="cr">If</span><span>     </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Term</span><span>
</span></code></pre></div>
<h3 id="定義-323-具体的な項の定義">定義 3.2.3 具体的な項の定義</h3>
<p>Haskell で定義するとするとこんな感じだろうか。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">s</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Int</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">T</span><span>
</span><span class="va">s</span><span> </span><span class="va">i</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">i</span><span> </span><span class="op">==</span><span> </span><span class="it">0</span><span>    </span><span class="sy">=</span><span> </span><span class="va">Set.empty</span><span>
  </span><span class="sy">|</span><span> </span><span class="va">otherwise</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.unions</span><span> </span><span class="sy">[</span><span class="va">s1</span><span class="sy">,</span><span> </span><span class="va">s2</span><span class="sy">,</span><span> </span><span class="va">s3</span><span class="sy">]</span><span>
  </span><span class="kw">where</span><span>
    </span><span class="va">s1</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.fromList</span><span> </span><span class="sy">[</span><span class="cr">True</span><span class="sy">,</span><span> </span><span class="cr">False</span><span class="sy">,</span><span> </span><span class="cr">Zero</span><span class="sy">]</span><span>
    </span><span class="va">s2</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.fromList</span><span> </span><span class="op">$</span><span> </span><span class="va">concat</span><span> </span><span class="sy">[</span><span class="sy">[</span><span class="cr">Succ</span><span> </span><span class="va">t1</span><span class="sy">,</span><span> </span><span class="cr">Pred</span><span> </span><span class="va">t1</span><span class="sy">,</span><span> </span><span class="cr">IsZero</span><span> </span><span class="va">t1</span><span class="sy">]</span><span> </span><span class="sy">|</span><span> </span><span class="va">t1</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">si</span><span class="sy">]</span><span>
    </span><span class="va">s3</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.fromList</span><span> </span><span class="sy">[</span><span class="cr">If</span><span> </span><span class="va">t1</span><span> </span><span class="va">t2</span><span> </span><span class="va">t3</span><span> </span><span class="sy">|</span><span> </span><span class="va">t1</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">si</span><span class="sy">,</span><span> </span><span class="va">t2</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">si</span><span class="sy">,</span><span> </span><span class="va">t3</span><span> </span><span class="sy">&lt;-</span><span> </span><span class="va">si</span><span class="sy">]</span><span>
    </span><span class="va">si</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.toList</span><span> </span><span class="op">$</span><span> </span><span class="va">s</span><span> </span><span class="sy">(</span><span class="va">i</span><span class="it">-1</span><span class="sy">)</span><span>
</span></code></pre></div>
<h2 id="33-項に関する帰納法">3.3 項に関する帰納法</h2>
<p>具体例を使って考える。</p>
<ul>
<li>
<span class="math inline">\(t_1 = true\)</span>
</li>
<li>
<span class="math inline">\(t_2 = pred \space t_1\)</span>
</li>
<li>
<span class="math inline">\(t_3 = succ \space 0\)</span>
</li>
<li>
<span class="math inline">\(t_4 = if \space t_1 \space then \space t_2 \space else \space t_3\)</span>
</li>
</ul>
<p><span class="math inline">\(t\)</span> の抽象構文木は次のように図示できる。</p>
<p><img src="./images/3-3.png" alt="tの抽象構文木"></p>
<h3 id="定義331-consts">定義3.3.1 <span class="math inline">\(Consts\)</span></h3>
<p>項 <span class="math inline">\(t_1\)</span> から <span class="math inline">\(t_4\)</span> に対して <span class="math inline">\(Consts\)</span> を計算すると、それぞれ以下のようになる。</p>
<p>\begin{eqnarray}Consts(t_1) &amp;=&amp; Consts(true) &amp;=&amp; \{true\} \\Consts(t_2) &amp;=&amp; Consts(pred \space t_1) = Consts(t_1) &amp;=&amp; \{true\} \\Consts(t_3) &amp;=&amp; Consts(succ \space 0) = Consts(0) &amp;=&amp; \{0\} \\Consts(t_4) &amp;=&amp; Consts(if \space t_1 \space then \space t_2 \space else \space t_3) \\            &amp;=&amp; Consts(t_1) \cup Consts(t_2) \cup Consts(t_3) \\            &amp;=&amp; \{true\} \cup \{true\} \cup \{0\} &amp;=&amp; \{true, 0\}\end{eqnarray}</p>
<p>Haskell で定義すると、だいたいこんな感じになると思う。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">consts</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">T</span><span>
</span><span class="va">consts</span><span> </span><span class="cr">True</span><span>          </span><span class="sy">=</span><span> </span><span class="va">Set.singleton</span><span> </span><span class="cr">True</span><span>
</span><span class="va">consts</span><span> </span><span class="cr">False</span><span>         </span><span class="sy">=</span><span> </span><span class="va">Set.singleton</span><span> </span><span class="cr">False</span><span>
</span><span class="va">consts</span><span> </span><span class="cr">Zero</span><span>          </span><span class="sy">=</span><span> </span><span class="va">Set.singleton</span><span> </span><span class="cr">Zero</span><span>
</span><span class="va">consts</span><span> </span><span class="sy">(</span><span class="cr">Succ</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">consts</span><span> </span><span class="va">t</span><span>
</span><span class="va">consts</span><span> </span><span class="sy">(</span><span class="cr">Pred</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">consts</span><span> </span><span class="va">t</span><span>
</span><span class="va">consts</span><span> </span><span class="sy">(</span><span class="cr">IsZero</span><span> </span><span class="va">t</span><span class="sy">)</span><span>    </span><span class="sy">=</span><span> </span><span class="va">consts</span><span> </span><span class="va">t</span><span>
</span><span class="va">consts</span><span> </span><span class="sy">(</span><span class="cr">If</span><span> </span><span class="va">t1</span><span> </span><span class="va">t2</span><span> </span><span class="va">t3</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">Set.unions</span><span> </span><span class="op">$</span><span> </span><span class="va">map</span><span> </span><span class="va">consts</span><span> </span><span class="sy">[</span><span class="va">t1</span><span class="sy">,</span><span> </span><span class="va">t2</span><span class="sy">,</span><span> </span><span class="va">t3</span><span class="sy">]</span><span>
</span></code></pre></div>
<h3 id="定義-332-size">定義 3.3.2 <span class="math inline">\(size\)</span></h3>
<p>先程定義した <span class="math inline">\(t_1\)</span> から <span class="math inline">\(t_4\)</span> を使って <span class="math inline">\(size\)</span> も具体的に計算してみる。</p>
<p>\begin{eqnarray}size(t_1) &amp;=&amp; size(true) &amp;=&amp; 1 \\size(t_2) &amp;=&amp; size(pred \space t_1) = size(t_1) + 1 = 1 + 1 &amp;=&amp; 2 \\size(t_3) &amp;=&amp; size(succ \space 0) = size(0) + 1 = 1 + 1 &amp;=&amp; 2 \\size(t_4) &amp;=&amp; size(if \space t_1 \space then \space t_2 \space else \space t_3) \\          &amp;=&amp; size(t_1) + size(t_2) + size(t_3) + 1 \\          &amp;=&amp; 1 + 2 + 2 + 1 &amp;=&amp; 6\end{eqnarray}</p>
<p>Haskell で定義すると、こんな感じだろう。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">size</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">size</span><span> </span><span class="cr">True</span><span>          </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="cr">False</span><span>         </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="cr">Zero</span><span>          </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="sy">(</span><span class="cr">Succ</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">size</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="sy">(</span><span class="cr">Pred</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">size</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="sy">(</span><span class="cr">IsZero</span><span> </span><span class="va">t</span><span class="sy">)</span><span>    </span><span class="sy">=</span><span> </span><span class="va">size</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">size</span><span> </span><span class="sy">(</span><span class="cr">If</span><span> </span><span class="va">t1</span><span> </span><span class="va">t2</span><span> </span><span class="va">t3</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">size</span><span> </span><span class="va">t1</span><span> </span><span class="op">+</span><span> </span><span class="va">size</span><span> </span><span class="va">t2</span><span> </span><span class="op">+</span><span> </span><span class="va">size</span><span> </span><span class="va">t3</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span></code></pre></div>
<h3 id="定義-332-depth">定義 3.3.2 <span class="math inline">\(depth\)</span></h3>
<p>先程と同様に具体例を確認する。</p>
<p>\begin{eqnarray}depth(t_1) &amp;=&amp; depth(true) &amp;=&amp; 1 \\depth(t_2) &amp;=&amp; depth(pred \space t_1) = depth(t_1) + 1 = 1 + 1 &amp;=&amp; 2 \\depth(t_3) &amp;=&amp; depth(succ \space 0) = depth(0) + 1 = 1 + 1 &amp;=&amp; 2 \\depth(t_4) &amp;=&amp; depth(if \space t_1 \space then \space t_2 \space else \space t_3) \\           &amp;=&amp; max(depth(t_1), depth(t_2), depth(t_3)) + 1 \\           &amp;=&amp; max(1, 2, 2) + 1 \\           &amp;=&amp; 2 + 1 &amp;=&amp; 3\end{eqnarray}</p>
<p>Haskell で定義すると、だいたいこんな感じ。</p>
<div class="source-code"><pre><code class="language-haskell"><span class="va">depth</span><span> </span><span class="sy">::</span><span> </span><span class="cr">Term</span><span> </span><span class="sy">-&gt;</span><span> </span><span class="cr">Int</span><span>
</span><span class="va">depth</span><span> </span><span class="cr">True</span><span>          </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="cr">False</span><span>         </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="cr">Zero</span><span>          </span><span class="sy">=</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="sy">(</span><span class="cr">Succ</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">depth</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="sy">(</span><span class="cr">Pred</span><span> </span><span class="va">t</span><span class="sy">)</span><span>      </span><span class="sy">=</span><span> </span><span class="va">depth</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="sy">(</span><span class="cr">IsZero</span><span> </span><span class="va">t</span><span class="sy">)</span><span>    </span><span class="sy">=</span><span> </span><span class="va">depth</span><span> </span><span class="va">t</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span><span class="va">depth</span><span> </span><span class="sy">(</span><span class="cr">If</span><span> </span><span class="va">t1</span><span> </span><span class="va">t2</span><span> </span><span class="va">t3</span><span class="sy">)</span><span> </span><span class="sy">=</span><span> </span><span class="va">maximum</span><span> </span><span class="sy">[</span><span class="va">depth</span><span> </span><span class="va">t1</span><span class="sy">,</span><span> </span><span class="va">depth</span><span> </span><span class="va">t2</span><span class="sy">,</span><span> </span><span class="va">depth</span><span> </span><span class="va">t3</span><span class="sy">]</span><span> </span><span class="op">+</span><span> </span><span class="it">1</span><span>
</span></code></pre></div>
<p><span class="math inline">\(depth(t)\)</span> は定義3.2.3において <span class="math inline">\(t \in S_i\)</span> となる最小の <span class="math inline">\(i\)</span> である。</p>
<p>具体例 (<span class="math inline">\(t_1\)</span>)</p>
<p>\begin{eqnarray}t_1 &amp;\in&amp; S_i \space ただし \space i = depth(t_1) \\t_1 &amp;\in&amp; S_1 \\true &amp;\in&amp; \{true, false, 0\}\end{eqnarray}</p>
<p>具体例 (<span class="math inline">\(t_2\)</span>)</p>
<p>\begin{eqnarray}t_2 &amp;\in&amp; S_i \space ただし \space i = depth(t_2) \\t_2 &amp;\in&amp; S_2 \\pred \space true &amp;\in &amp;\{ \space true, false, 0 \\                 &amp;      &amp;, \space succ \space true, succ \space false, succ \space 0 \\                 &amp;      &amp;, \space pred \space true, pred \space false, pred \space 0 \\                 &amp;      &amp;, \space iszero \space true, iszero \space false, iszero \space 0 \\                 &amp;      &amp;, \space if \space true \space then \space true \space else \space true \\                 &amp;      &amp;, \space if \space true \space then \space true \space else \space false \\                 &amp;      &amp;, \space if \space true \space then \space true \space else \space 0 \\                 &amp;      &amp;, \space if \space true \space then \space false \space else \space true \\                 &amp;      &amp;, \space if \space true \space then \space false \space else \space false \\                 &amp;      &amp;, \space if \space true \space then \space false \space else \space 0 \\                 &amp;      &amp;, \space if \space true \space then \space 0 \space else \space true \\                 &amp;      &amp;, \space if \space true \space then \space 0 \space else \space false \\                 &amp;      &amp;, \space if \space true \space then \space 0 \space else \space 0 \\                 &amp;      &amp;, \space if \space false \space then \space true \space else \space true \\                 &amp;      &amp;, \space if \space false \space then \space true \space else \space false \\                 &amp;      &amp;, \space if \space false \space then \space true \space else \space 0 \\                 &amp;      &amp;, \space if \space false \space then \space false \space else \space true \\                 &amp;      &amp;, \space if \space false \space then \space false \space else \space false \\                 &amp;      &amp;, \space if \space false \space then \space false \space else \space 0 \\                 &amp;      &amp;, \space if \space false \space then \space 0 \space else \space true \\                 &amp;      &amp;, \space if \space false \space then \space 0 \space else \space false \\                 &amp;      &amp;, \space if \space false \space then \space 0 \space else \space 0 \\                 &amp;      &amp;, \space if \space 0 \space then \space true \space else \space true \\                 &amp;      &amp;, \space if \space 0 \space then \space true \space else \space false \\                 &amp;      &amp;, \space if \space 0 \space then \space true \space else \space 0 \\                 &amp;      &amp;, \space if \space 0 \space then \space false \space else \space true \\                 &amp;      &amp;, \space if \space 0 \space then \space false \space else \space false \\                 &amp;      &amp;, \space if \space 0 \space then \space false \space else \space 0 \\                 &amp;      &amp;, \space if \space 0 \space then \space 0 \space else \space true \\                 &amp;      &amp;, \space if \space 0 \space then \space 0 \space else \space false \\                 &amp;      &amp;, \space if \space 0 \space then \space 0 \space else \space 0 \\                 &amp;    &amp;\}\end{eqnarray}</p>
<h3 id="補題-333">補題 3.3.3</h3>
<p>ある項 <span class="math inline">\(t\)</span> の中の異なる定数の数は <span class="math inline">\(t\)</span> のサイズ以下である。つまり</p>
<p><span class="math display">\[\mid \space Consts(t) \space | \leq size(t)\]</span></p>
<p>具体例 (<span class="math inline">\(t_1\)</span>)</p>
<p>\begin{eqnarray}\mid \space Consts(t_1) \space | &amp;\leq&amp; size(t_1) \\1 &amp;\leq&amp; 1\end{eqnarray}</p>
<p>具体例 (<span class="math inline">\(t_4\)</span>)</p>
<p>\begin{eqnarray}\mid \space Consts(t_4) \space | &amp;\leq&amp; size(t_4) \\2 &amp;\leq&amp; 6\end{eqnarray}</p>
<h3 id="定理-334-深さに関する帰納法">定理 3.3.4 深さに関する帰納法</h3>
<p>各項 <span class="math inline">\(s\)</span> に対して 「<span class="math inline">\(depth(r) &lt; depth(s)\)</span> なる任意の <span class="math inline">\(r\)</span> に対して <span class="math inline">\(P(r)\)</span> が成り立つ時、<span class="math inline">\(P(s)\)</span> が証明できる」ならば、すべての <span class="math inline">\(s\)</span> に対して <span class="math inline">\(P(s)\)</span> が成り立つ。</p>
<p>証明は自然数上の完全帰納法を使う。</p>
<p><span class="math inline">\(P\)</span> を自然数上の述語とする。このとき、各自然数 <span class="math inline">\(n\)</span> に対して、「任意の <span class="math inline">\(i &lt; n\)</span> に対して <span class="math inline">\(P(i)\)</span> が成り立つとき、<span class="math inline">\(P(n)\)</span> が証明できる」ならば、すべての <span class="math inline">\(n\)</span> に対して <span class="math inline">\(P(n)\)</span> が成り立つ。</p>
<p><strong>失敗</strong> したやり方</p>
<ul>
<li>
<span class="math inline">\(n = depth(s)\)</span>
</li>
<li>
<span class="math inline">\(i = depth(r)\)</span>
</li>
</ul>
<p>としてみる。</p>
<p>各自然数 <span class="math inline">\(depth(s)\)</span> に対して、「任意の <span class="math inline">\(depth(r) &lt; depth(s)\)</span> に対して <span class="math inline">\(P(depth(r))\)</span> が成り立つとき、<span class="math inline">\(P(depth(s))\)</span> が証明できる」ならば、すべての <span class="math inline">\(depth(s)\)</span> に対して <span class="math inline">\(P(depth(s))\)</span> が成り立つ。</p>
<p>これだと、本来は <span class="math inline">\(s\)</span> について成り立つことを言いたいのだが <span class="math inline">\(depth(s)\)</span> について成り立つということしか言えなくなってしまう。なのでおかしい。</p>
<p><strong>正しい</strong> 証明</p>
<p>自然数上の述語 <span class="math inline">\(Q\)</span> を次のように定義する。</p>
<p><span class="math display">\[Q(n) = \forall s. depth(s) = n \Rightarrow P(s)\]</span></p>
<p><span class="math inline">\(depth(s)\)</span> と <span class="math inline">\(n\)</span> が上手くつながり、<span class="math inline">\(s\)</span> について成り立つことが言えるようになった。</p>
<h3 id="定理-334-サイズに関する帰納法">定理 3.3.4 サイズに関する帰納法</h3>
<p><span class="math display">\[Q(n) = \forall s. size(s) = n \Rightarrow P(s)\]</span></p>
<p>公理 2.4.2 より成り立つ。</p>
<h3 id="定理-334-構造的帰納法">定理 3.3.4 構造的帰納法</h3>
<p><span class="math display">\[Q(n) = \forall s. f(s) = n \Rightarrow P(s)\]</span></p>
<p>ここで <span class="math inline">\(f\)</span> を次のように定義する。</p>
<p>\begin{eqnarray}f(true) &amp;=&amp; 0 \\f(false) &amp;=&amp; 0 \\f(0) &amp;=&amp; 0 \\f(succ \space t) &amp;=&amp; f(t) + 1 \\f(pred \space t) &amp;=&amp; f(t) + 1 \\f(iszero \space t) &amp;=&amp; f(t) + 1 \\f(if \space t_1 \space then \space t_2 \space else \space t_3) &amp;=&amp; max(f(t_1), f(t_2), f(t_3)) + 1 \\\end{eqnarray}</p>
<p>公理 2.4.1 より成り立つ。</p>
<h2 id="34-意味論のスタイル">3.4 意味論のスタイル</h2>
<h3 id="操作的意味論">操作的意味論</h3>
<p><strong>抽象機械</strong> を定義することでプログラミング言語の <strong>振る舞い</strong> を規定。項を機械語として扱う。</p>
<ul>
<li>
機械の状態・・・項
</li>
<li>
機械の振る舞い・・・遷移関数
</li>
</ul>
<h3 id="表示的意味論">表示的意味論</h3>
<ul>
<li>
項を数値や関数などの数学的対象として捉える
</li>
<li>
言語に表示的意味を与える
<ul>
<li>
意味領域の集まりを見つける
</li>
<li>
項を意味領域の元に写す解釈関数を定義する
</li>
</ul>
</li>
</ul>
<p>苦手</p>
<ul>
<li>
非決定性
</li>
<li>
並行性
</li>
</ul>
<h3 id="公理的意味論">公理的意味論</h3>
<ul>
<li>
言語の定義として法則自身をとる
</li>
<li>
項の意味はその項について証明できる事実
</li>
</ul>
<p>苦手</p>
<ul>
<li>
手続き
</li>
</ul>
<h2 id="35-評価-簡約">3.5 評価 (簡約)</h2>
<h3 id="項の構文">項の構文</h3>
<p>\begin{eqnarray}t &amp;::= &amp; true \\     &amp; &amp; false \\     &amp; &amp; if \space t \space then \space t \space else \space t\end{eqnarray}</p>
<h3 id="項の値">項の値</h3>
<p>評価の最終結果となりうる項の部分集合</p>
<p>\begin{eqnarray}v &amp;::= &amp; true \\     &amp; &amp; false\end{eqnarray}</p>
<p>メタ変数 <span class="math inline">\(v\)</span> は (本書では) 専ら値のために使われる。</p>
<h3 id="項の評価関係">項の評価関係</h3>
<p><span class="math inline">\(t \rightarrow t&#39;\)</span> は <span class="math inline">\(t\)</span> が <strong>1ステップ</strong> で <span class="math inline">\(t&#39;\)</span> に評価されるという意味。</p>
<p><img src="./images/3-5-eval.png" alt="項の評価関係図"></p>
<h4 id="計算規則">計算規則</h4>
<p><span class="math display">\[if \space true \space then \space t_2 \space else \space t_3 \rightarrow t_2 (E-IFTRUE)\]</span><span class="math display">\[if \space false \space then \space t_2 \space else \space t_3 \rightarrow t_3 (E-IFFALSE)\]</span></p>
<h4 id="合同規則">合同規則</h4>
<p>TODO (mathjax で証明木を書く良い方法が無い)</p>
<h4 id="ポイント">ポイント</h4>
<ul>
<li>
<span class="math inline">\(true, false\)</span> は規則の左側に出現しないため、これ以上評価されない。
</li>
<li>
先に <span class="math inline">\(then, else\)</span> から評価するという規則もない
</li>
</ul>
<p>具体例</p>
<p>TODO</p>
<p>規則間の相互作用によって評価戦略を定める。</p>
<h3 id="定義-351-推論規則のインスタンス">定義 3.5.1 推論規則のインスタンス</h3>
<p>推論規則のインスタンスとは</p>
<ul>
<li>
規則の結論
</li>
<li>
前提
</li>
</ul>
<p>のメタ変数それぞれに対し、一貫して同じ項による置き換えを行ったもの。</p>
<p>具体例</p>
<p><span class="math display">\[if \space true \space then \space true \space else \space (if \space false \space then \space false \space else \space false) \rightarrow true\]</span></p>
<p>は <span class="math inline">\(E-IFTRUE\)</span> のインスタンスである。</p>
<ul>
<li>
<span class="math inline">\(if \space true \space then \space t_2 \space else \space t_3 \rightarrow t_2\)</span>
</li>
<li>
<span class="math inline">\(t_2 = true\)</span>
</li>
<li>
<span class="math inline">\(t_3 = if \space false \space then \space false \space else \space false\)</span>
</li>
</ul>
<h3 id="定義-352">定義 3.5.2</h3>
<p>規則がある関係によって <strong>満たされる</strong> とは <strong>規則の任意のインスタンス</strong> について</p>
<ul>
<li>
<strong>結論がその関係に属する</strong>
</li>
</ul>
<p>または</p>
<ul>
<li>
<strong>前提のうち1つが属さない</strong>
</li>
</ul>
<p>ことを言う。</p>
<h2 id="日本語の文献">日本語の文献</h2>
<ul>
<li>
<a href="http://www.nue.ie.niigata-u.ac.jp/toyama/lab-intro/TRS-intro/index.html">項書き換えシステム入門</a>
</li>
<li>
<a href="http://logic.cs.tsukuba.ac.jp/ppl2016/slides/ppltut.pdf">プログラミング言語のための書換え系入門</a>
</li>
<li>
<a href="http://kussharo.complex.eng.hokudai.ac.jp/~kurihara/classes/Program/trs.pdf">項書換え系（１） 代数的仕様と項書換え</a>
</li>
<li>
<a href="http://kussharo.complex.eng.hokudai.ac.jp/~kurihara/classes/Program/termination.pdf">項書換え系（２） 停止性</a>
</li>
<li>
<a href="http://kussharo.complex.eng.hokudai.ac.jp/~kurihara/classes/Program/confluence.pdf">項書換え系（３） 合流性</a>
</li>
<li>
<a href="http://www.cs.tsukuba.ac.jp/~kam/lecture/complogic2015/main.pdf">『計算論理学』講義資料</a>
</li>
<li>
<a href="https://www.math.nagoya-u.ac.jp/~garrigue/papers/danwakai2015.pdf">型システムとプログラミング言語</a>
</li>
<li>
<a href="https://www.trs.css.i.nagoya-u.ac.jp/person/nishida/DB/pdf/lecture20061124.pdf">情報システム学特論</a>
</li>
<li>
<a href="https://www.trs.css.i.nagoya-u.ac.jp/~sakai/lecture/trs/">計算論基礎特論A、平成30年度版</a>
</li>
</ul>
<h2 id="英語の文献">英語の文献</h2>
<ul>
<li>
<a href="http://www.cs.tau.ac.il/~nachumd/models/CR.pdf">Church-Rosser</a>
</li>
</ul>
<h2 id="ニューマンの補題">ニューマンの補題</h2>
<ul>
<li>
<a href="https://mathoverflow.net/questions/289300/newmans-lemma-or-diamond-lemma">Newman’s Lemma or Diamond Lemma</a>
</li>
<li>
<a href="https://pdfs.semanticscholar.org/f63b/2678f4b80a79711daefbdf1893b0d35f97cb.pdf">Newman’s Proof of Newman’s Lemma</a>
</li>
</ul>
<h2 id="整礎帰納法">整礎帰納法</h2>
<ul>
<li>
<a href="https://www.fos.kuis.kyoto-u.ac.jp/~igarashi/class/sf03w/resume3.pdf">ソフトウェア基礎論 配布資料(3)</a>
</li>
</ul>
<h2 id="haskell">Haskell</h2>
<ul>
<li>
<a href="https://pdfs.semanticscholar.org/e07d/8cda9a181c2fd3504c8ac527629089206e13.pdf">A Haskell Library for Term Rewriting∗</a>
</li>
<li>
<a href="https://github.com/jwaldmann/matchbox">jwaldmann/matchbox</a>
</li>
<li>
<a href="https://github.com/pepeiborra/muterm-framework">pepeiborra/muterm-framework</a>
</li>
<li>
<a href="https://github.com/ComputationWithBoundedResources/tct-trs">ComputationWithBoundedResources/tct-trs</a>
</li>
<li>
<a href="https://github.com/haskell-rewriting">Haskell Rewriting</a>
</li>
</ul>
<h2 id="クヌースベンディックス完備化アルゴリズム">クヌース・ベンディックス完備化アルゴリズム</h2>
<ul>
<li>
<a href="https://qiita.com/unsolvedprobrem/items/bbbe7da332515bfc73ee">C++でKnuth-Bendixの完備化アルゴリズムを頑張って実装した話</a>
</li>
<li>
<a href="https://ja.wikipedia.org/wiki/%e3%82%af%e3%83%8c%e3%83%bc%e3%82%b9%e3%83%bb%e3%83%99%e3%83%b3%e3%83%87%e3%82%a3%e3%83%83%e3%82%af%e3%82%b9%e5%ae%8c%e5%82%99%e5%8c%96%e3%82%a2%e3%83%ab%e3%82%b4%e3%83%aa%e3%82%ba%e3%83%a0">クヌース・ベンディックス完備化アルゴリズム</a>
</li>
<li>
<a href="https://github.com/mfejzer/knuth-bendix-completion">mfejzer/knuth-bendix-completion</a>
</li>
<li>
<a href="https://gist.github.com/marionette-of-u/e563bdf9096fc47dff90">marionette-of-u/trs-lie-ring.ml</a>
</li>
<li>
<a href="http://www21.in.tum.de/~nipkow/TRaAT/programs/">Knuth-Bendix completion à la Huet.</a>
</li>
<li>
<a href="https://functionallens.wordpress.com/2007/12/20/infinite-lazy-knuth-bendix-completion-for-monoids-in-haskell/">INFINITE LAZY KNUTH-BENDIX COMPLETION FOR MONOIDS IN HASKELL</a>
</li>
<li>
<a href="http://www.math.nagoya-u.ac.jp/ja/public/agora/download/agora-2005s-cd-b.pdf">書き換えと計算機</a>
</li>
<li>
<a href="https://ci.nii.ac.jp/els/contentscinii_20180606003054.pdf?id=ART0004920806">Knuth−Bendixの完備化手続きとその応用</a>
</li>
</ul>
<h2 id="ocaml">Ocaml</h2>
<ul>
<li>
<a href="http://www.math.nagoya-u.ac.jp/~garrigue/lecture/tsukuba16/index.html">2015年度 筑波大学 ソフトウェア技法・OCaml入門</a>
</li>
<li>
<a href="http://logic.cs.tsukuba.ac.jp/jikken/">筑波大学 情報科学類 3年次実験（ソフトウェアサイエンス実験）</a>
</li>
<li>
<a href="http://www.cs.tsukuba.ac.jp/~kam/lecture/fp2018/">ソフトウェア技法 (2年次向け, 春C, 火1-2+金3-4)</a>
</li>
<li>
<a href="https://www.eidos.ic.i.u-tokyo.ac.jp/~tau/lecture/programming_languages/gen/html/ocaml.html">プログラミング言語: OCaml演習</a>
</li>
<li>
<a href="https://github.com/aigarashi/PL-LectureNotes">工学部専門科目「プログラミング言語」講義資料(2017年度)</a>
</li>
<li>
<a href="https://try.ocamlpro.com/">Try OCaml</a>
</li>
</ul>
</div></div></section></body></html>