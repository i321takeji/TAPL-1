-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package tapl
@version 0.0.0

module Language.B.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
data Rule
E_IFTRUE :: Rule
E_IFFALSE :: Rule
E_IF :: Rule
newtype EvalRelation
EvalRelation :: (Term, Term) -> EvalRelation
[unwrap] :: EvalRelation -> (Term, Term)
type Premise = EvalRelation
type Conclusion = EvalRelation
instance GHC.Show.Show Language.B.Types.EvalRelation
instance GHC.Classes.Eq Language.B.Types.EvalRelation
instance GHC.Show.Show Language.B.Types.Rule
instance GHC.Enum.Bounded Language.B.Types.Rule
instance GHC.Enum.Enum Language.B.Types.Rule
instance GHC.Show.Show Language.B.Types.Term
instance GHC.Classes.Eq Language.B.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.EvalRelation
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Rule
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.B.Types.Term

module Language.B.Example
example :: EvalRelation

module Language.NB.Types
data Term
TmTrue :: Term
TmFalse :: Term
TmIf :: Term -> Term -> Term -> Term
TmZero :: Term
TmSucc :: Term -> Term
TmPred :: Term -> Term
TmIsZero :: Term -> Term
data TmError
NoRuleApplies :: TmError
instance GHC.Show.Show Language.NB.Types.TmError
instance GHC.Classes.Eq Language.NB.Types.TmError
instance GHC.Show.Show Language.NB.Types.Term
instance GHC.Classes.Eq Language.NB.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.NB.Types.Term

module Language.UntypedLambda.Types
data Term
TmVar :: Text -> Term
TmLam :: Text -> Term -> Term
TmApp :: Term -> Term -> Term
data Strategy

-- | 完全ベータ簡約
FullBetaReduction :: Strategy

-- | 正規順序戦略
NormalOrder :: Strategy

-- | 名前呼び戦略
CallByName :: Strategy

-- | 値呼び戦略
CallByValue :: Strategy
instance GHC.Show.Show Language.UntypedLambda.Types.Term
instance GHC.Classes.Eq Language.UntypedLambda.Types.Term
instance Data.Text.Prettyprint.Doc.Internal.Pretty Language.UntypedLambda.Types.Term
instance Data.String.IsString Language.UntypedLambda.Types.Term

module Language.UntypedLambda.Prelude

-- | λx. x
id :: Term

-- | λt. λf. t
tru :: Term

-- | λt. λf. f
fls :: Term

-- | λl. λm. λn. l m n
test :: Term

-- | λb. λc. b c fls
and :: Term

-- | λb. λc. b tru c
or :: Term

-- | λb. b fls tru
not :: Term

-- | λf. λs. λb. b f s
pair :: Term

-- | λp. p tru
fst :: Term

-- | λp. p fls
snd :: Term

-- | c0 = λs. λz. z
--   
--   c1 = λs. λz. s z
--   
--   c2 = λs. λz. s (s z)
--   
--   c3 = λs. λz. s (s (s z))
c :: Int -> Term

-- | λn. λs. λz. s (n s z)
scc :: Term

-- | λm. λn. λs. λz. m s (n s z)
plus :: Term

-- | λm. λn. m (plus n) c0
times :: Term

-- | λm. m (λx. fls) tru
iszro :: Term

-- | λm. fst (m ss zz)
prd :: Term

-- | λn. λs. λz. n s (s z)
scc2 :: Term

-- | λm. λn. λs. λz. m (n s) z
times2 :: Term

-- | λm. λn. λs. m (n s)
times3 :: Term

-- | λn. λm. m (times n) c1 n^m
power1 :: Term

-- | λn. λm. m n m^n
power2 :: Term

-- | λm. λn. n prd m
subtract1 :: Term

-- | λm. λn. and (iszro (m prd n)) (iszro (n prd m))
equal :: Term

module Language.Utils
trim :: String -> String
render :: Pretty a => a -> String

module Language.Utils.Parser
runParserString :: Parser a -> String -> Either String a

module Language.UntypedLambda.Parser
runUlParser :: String -> Either String Term

module Language.UntypedLambda

-- | 与えられた項が閉じているかどうか判定する述語
isClosed :: Term -> Bool

-- | 正規順序戦略
reduceNormalOrder :: Term -> Term

-- | 名前呼び戦略
reduceCallByName :: Term -> Term

-- | 値呼び戦略
reduceCallByValue :: Term -> Term

-- | 指定された評価戦略で項を正規系に評価する
eval :: Strategy -> Term -> Term

-- | 簡約ステップ列を返す
evalWithTrace :: Strategy -> [Term] -> Term -> [Term]

-- | 1ステップのみ、指定された評価戦略で評価する
evalOneStep :: Strategy -> Term -> Term

-- | デバッグ用
trace :: Strategy -> Term -> IO ()

-- | 簡約ステップ数を返す
steps :: Term -> Int

module Language.UntypedLambda.Examples

-- | s t u
example1 :: Term

-- | λx. (λy. ((x y) x))
example2 :: Term

-- | (λx.x) ((λx.x) (λz. (λx.x) z))
example3 :: Term

-- | (λx.x) x
example4 :: Term

-- | λz. λx. λy. x (y z)
example5 :: Term

-- | (λx. x (λx. x)) (u r)
example6 :: Term

-- | test tru tru fls
example7 :: Term

-- | and tru tru
example8 :: Term

-- | and tru fls
example9 :: Term

-- | fst (pair v w)
example10 :: Term

module Language.NB.Parser
runNbParser :: String -> Either String Term

module Language.NB
isNumericalVal :: Term -> Bool
isVal :: Term -> Bool
eval :: Term -> Term

module Language.B.Parser
bparser :: String -> Either String EvalRelation
stepCmdParser :: String -> Either String Int

module Language.B
deduce :: Rule -> Conclusion -> Maybe Premise
step :: Rule -> Maybe Premise -> Maybe Premise

-- | 項の評価関係
--   
--   評価関係 t -&gt; t' は「tが1ステップでt'に評価される」と読む
reduction :: Maybe Premise -> Term -> Term

module Language.Utils.Pretty
prettyText :: Pretty a => a -> Text

module Term.Types

-- | <ul>
--   <li><i>定義 3.2.1 帰納的な項の定義</i></li>
--   </ul>
--   
--   <ul>
--   <li>項の集合とは3つの条件を満たす最小の集合Tである</li>
--   <li>「最小の」という言葉は T が3つの条件によって要求される要素以外を持たないという意味。</li>
--   <li>True, False は Bool の値とかぶるので先頭に T をつけることにする</li>
--   <li>全てが Term の値であることを明示的にするため、GADT で書いたが、普通に ADT で書いても良い</li>
--   </ul>
data Term
[TTrue] :: Term
[TFalse] :: Term
[Zero] :: Term
[Succ] :: Term -> Term
[Pred] :: Term -> Term
[IsZero] :: Term -> Term
[If] :: Term -> Term -> Term -> Term
instance GHC.Generics.Generic Term.Types.Term
instance GHC.Show.Show Term.Types.Term
instance GHC.Classes.Ord Term.Types.Term
instance GHC.Classes.Eq Term.Types.Term
instance Data.Hashable.Class.Hashable Term.Types.Term
instance Test.QuickCheck.Arbitrary.Arbitrary Term.Types.Term

module Term.Set

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T

module Term.HashSet

-- | <ul>
--   <li><i>定義 3.2.3 具体的な項の定義</i> 各自然数 i について、集合 Si を以下のように定義する。</li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; s 0
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; s 1
--   fromList [TTrue,TFalse,Zero]
--   </pre>
s :: Int -> T

-- | <ul>
--   <li><i>定義 3.3.1 項tに現れる定数の集合を Consts(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; consts TTrue
--   fromList [TTrue]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; consts (Succ (Succ (Succ Zero)))
--   fromList [Zero]
--   </pre>
consts :: Term -> T

-- | <ul>
--   <li><i>定義 3.3.2 項tのサイズを size(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; size Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; size (If Zero (Succ (Succ Zero)) (Succ Zero))
--   7
--   </pre>
size :: Term -> Int

-- | <ul>
--   <li><i>項tの深さを depth(t) と書き、次のように定義する</i></li>
--   </ul>
--   
--   <pre>
--   &gt;&gt;&gt; depth Zero
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (Succ (Succ (Succ Zero)))
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; depth (If Zero (Succ (Succ Zero)) (Succ Zero))
--   4
--   </pre>
depth :: Term -> Int

-- | 与えられた Term が含まれる、最小の集合 T を作る
--   
--   <pre>
--   &gt;&gt;&gt; minT Zero
--   fromList [TTrue,TFalse,Zero]
--   </pre>
minT :: Term -> T
